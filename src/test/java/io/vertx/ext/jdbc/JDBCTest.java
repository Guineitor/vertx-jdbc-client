package io.vertx.ext.jdbc;

import io.vertx.core.Vertx;
import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.sql.ResultSet;
import io.vertx.ext.sql.SQLClient;
import io.vertx.ext.sql.SQLConnection;
import io.vertx.ext.unit.Async;
import io.vertx.ext.unit.TestContext;
import io.vertx.ext.unit.junit.VertxUnitRunner;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;

@RunWith(VertxUnitRunner.class)
public class JDBCTest {

  private static final List<String> SQL = new ArrayList<>();

  private final Vertx vertx = Vertx.vertx();
  private SQLClient client;

  static {
    System.setProperty("textdb.allow_full_path", "true");
    //TODO: Create table with more types for testing
    SQL.add("drop table if exists select_table;");
    SQL.add("drop table if exists insert_table;");
    SQL.add("drop table if exists insert_table2;");
    SQL.add("drop table if exists update_table;");
    SQL.add("drop table if exists delete_table;");
    SQL.add("drop table if exists blob_table;");
    SQL.add("drop table if exists big_table;");
    SQL.add("create table select_table (id int, lname varchar(255), fname varchar(255) );");
    SQL.add("insert into select_table values (1, 'doe', 'john');");
    SQL.add("insert into select_table values (2, 'doe', 'jane');");
    SQL.add("create table insert_table (id int generated by default as identity (start with 1 increment by 1) not null, lname varchar(255), fname varchar(255), dob date );");
    SQL.add("create table insert_table2 (id int not null, lname varchar(255), fname varchar(255), dob date );");
    SQL.add("create table update_table (id int, lname varchar(255), fname varchar(255), dob date );");
    SQL.add("insert into update_table values (1, 'doe', 'john', '2001-01-01');");
    SQL.add("create table delete_table (id int, lname varchar(255), fname varchar(255), dob date );");
    SQL.add("insert into delete_table values (1, 'doe', 'john', '2001-01-01');");
    SQL.add("insert into delete_table values (2, 'doe', 'jane', '2002-02-02');");
    SQL.add("create table blob_table (b blob, c clob, a int array default array[]);");
    SQL.add("insert into blob_table (b, c, a) values (load_file('pom.xml'), convert('Hello', clob),  ARRAY[1,2,3])");
    SQL.add("create table big_table(id int primary key, name varchar(255))");
    for (int i = 0; i < 200; i++) {
      SQL.add("insert into big_table values(" + i + ", 'Hello')");
    }
  }

  @Before
  public void setUp(TestContext should) throws SQLException {
    final Async test = should.async();

    JsonObject config = ConfigFactory.createConfigForHSQLDB();
    client = JDBCClient.createNonShared(vertx, config);

    client.getConnection(res -> {
      should.assertTrue(res.succeeded());
      SQLConnection conn = res.result();
      // abuse the system here!
      // i'll run blocking code in order to quickly setup the test database
      Connection jdbcConn = conn.unwrap();
      try {
        for (String sql : SQL) {
          jdbcConn.createStatement().execute(sql);
        }
      } catch (SQLException e) {
        should.fail(e);
      }
      conn.close(res1 -> {
        should.assertTrue(res.succeeded());
        test.complete();
      });
    });

    test.await();
  }

  @After
  public void after(TestContext should) {
    final Async test = should.async();
    client.close(res -> {
      should.assertTrue(res.succeeded());
      test.complete();
    });
    test.await();
  }

  @Test
  public void testSelect(TestContext should) {
    final Async test = should.async();

    String sql = "SELECT ID, FNAME, LNAME FROM select_table ORDER BY ID";

    client.getConnection(res -> {
      should.assertTrue(res.succeeded());
      SQLConnection conn = res.result();

      conn.query(sql, res1 -> {
        should.assertTrue(res1.succeeded());
        should.assertNotNull(res1.result());

        final ResultSet resultSet = res1.result();

        should.assertEquals(2, resultSet.getResults().size());
        should.assertEquals("ID", resultSet.getColumnNames().get(0));
        should.assertEquals("FNAME", resultSet.getColumnNames().get(1));
        should.assertEquals("LNAME", resultSet.getColumnNames().get(2));

        JsonArray result0 = resultSet.getResults().get(0);
        should.assertEquals(1, (int) result0.getInteger(0));
        should.assertEquals("john", result0.getString(1));
        should.assertEquals("doe", result0.getString(2));

        JsonArray result1 = resultSet.getResults().get(1);
        should.assertEquals(2, (int) result1.getInteger(0));
        should.assertEquals("jane", result1.getString(1));
        should.assertEquals("doe", result1.getString(2));
        test.complete();
      });

      test.await();
    });
  }


  @Test
  public void testUpdateWithParams(TestContext should) {
    final Async test = should.async();

    client.getConnection(res -> {
      should.assertTrue(res.succeeded());
      SQLConnection conn = res.result();

      String sql = "UPDATE update_table SET fname = ? WHERE id = ?";
      JsonArray params = new JsonArray().add("bob").add(1);

      conn.updateWithParams(sql, params, res1 -> {
        should.assertTrue(res1.succeeded());
        should.assertNotNull(res1.result());
        should.assertEquals(1, res1.result().getUpdated());

        conn.query("SELECT fname FROM update_table WHERE id = 1", res2 -> {
          should.assertTrue(res2.succeeded());
          should.assertNotNull(res2.result());

          should.assertEquals(1, res2.result().getResults().size());
          should.assertEquals("bob", res2.result().getResults().get(0).getString(0));

          conn.close(res3 -> {
            should.assertTrue(res3.succeeded());
            test.complete();
          });
        });
      });

    });

    test.await();
  }
}
